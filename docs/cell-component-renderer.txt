Cell Components

angular logoAngular
Custom HTML / DOM inside Cells is achieved using Cell Components. Create Custom Cell Components to have any HTML markup in a cell. The grid comes with some Provided Cell Components for common grid tasks.

Angular Cell Renderers thumbnail
The example below shows adding images, hyperlinks, and buttons to a cell using Custom Cell Components. The custom button logs to the developer console when clicked.


Console
Clear
Console logs from the example shown here...
 Code
Copy Link
New Tab
CodeSandbox
Plunker
Provided Components
Copy Link
The grid comes with some built in Cell Components that cover some common cell rendering requirements.

Group Cell Component: For showing group details with expand and collapse functionality when using any of Row Grouping, Master Detail or Tree Data.

Animate Change Cell Renderers: For animating changes when data is updated.

Checkbox Cell Renderer: For displaying boolean values with a checkbox when cellDataType of Boolean is used.

Custom Components
Copy Link
The interface for the Cell Component is as follows:

interface ICellRendererAngularComp {
    // Mandatory - Params for rendering
    agInit(params: ICellRendererParams): void;

    // Mandatory - Return true if you have managed the cell refresh yourself in this method, otherwise return false.
    // If you return false, the grid will remove the component from the DOM and create a new component in its place
    // with the new values.
    refresh(params: ICellRendererParams): boolean;
}
The Component is provided props containing, amongst other things, the value to be rendered.

class CustomButtonComponent implements ICellRendererAngularComp {
  // ...
  agInit(props: ICellRendererParams): void {
    this.cellValue = props.value;
  }
  // ...
Properties available on the ICellRendererParams<TData = any, TValue = any, TContext = any> interface.

value
Copy Link
TValue | null | undefined
Value to be rendered.
valueFormatted
Copy Link
string | null | undefined
Formatted value to be rendered.
fullWidth
Copy Link
boolean
True if this is a full width row.
pinned
Copy Link
'left' | 'right' | null
Pinned state of the cell.
data
Copy Link
TData | undefined
The row's data. Data property can be undefined when row grouping or loading infinite row models.
node
Copy Link
IRowNode
The row node.
colDef
Copy Link
ColDef
The cell's column definition.
column
Copy Link
Column
The cell's column.
eGridCell
Copy Link
HTMLElement
The grid's cell, a DOM div element.
eParentOfValue
Copy Link
HTMLElement
The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection.
getValue
Copy Link

Function
Convenience function to get most recent up to data value.
setValue
Copy Link

Function
Convenience function to set the value.
formatValue
Copy Link

Function
Convenience function to format a value using the column's formatter.
refreshCell
Copy Link

Function
Convenience function to refresh the cell.
registerRowDragger
Copy Link

Function
registerRowDragger:
rowDraggerElement The HTMLElement to be used as Row Dragger
dragStartPixels The amount of pixels required to start the drag (Default: 4)
value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.
suppressVisibilityChange Set to true to prevent the Grid from hiding the Row Dragger when it is disabled.
setTooltip
Copy Link

Function
Sets a tooltip to the main element of this component.
value The value to be displayed by the tooltip
shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when enableBrowserTooltips={true}.
api
Copy Link
GridApi
The grid api.
context
Copy Link
TContext
Application context as set on gridOptions.context.
Note that if Row Selection is enabled, it is recommended to set suppressKeyboardEvent on the column definition to prevent the ‚ê£ Space key from triggering both row selection and toggling the checkbox.

Cell Component Function
Copy Link
Instead of using an Angular component, it's possible to use a function for a Cell Component.

This is useful if you have a simple String value to render and want to avoid the overhead of an Angular component.

In the example below we're outputting a string value that depends on the cell value:

@Component({
    selector: 'my-app',
    template: `
        <ag-grid-angular
                [columnDefs]="columnDefs"
                ...other properties />`
})
export class AppComponent {
    columnDefs = [
        {
            headerName: "Value",
            field: "value",
            cellRenderer: params => params.value > 1000 ? "LARGE VALUE" : "SMALL VALUE"
        }
    ];
    //...
}
It is also possible to write a JavaScript-based Cell Renderer Component - refer to the docs here for more information

Selecting Components
Copy Link
The Cell Component for a Column is set via colDef.cellRenderer and can be any of the following types:

String: The name of a registered Cell Component, see Registering Custom Components
Class: Direct reference to a Cell Component.
Function: A function that returns either an HTML string or DOM element for display.
The code snippet below demonstrates each of these method types.

<ag-grid-angular
    [columnDefs]="columnDefs"
    /* other grid options ... */ />

this.columnDefs = [
    // 1 - String - The name of a Cell Component registered with the grid.
    {
        field: 'age',
        cellRenderer: 'agGroupCellRenderer',
    },
    // 2 - Class - Provide your own Cell Component directly without registering.
    {
        field: 'sport',
        cellRenderer: MyCustomCellRendererClass,
    },
    // 3 - Function - A function that returns an HTML string or DOM element for display
    {
        field: 'year',
        cellRenderer: params => {
            // put the value in bold
            return 'Value is <b>' + params.value + '</b>';
        }
    }
];
Dynamic Component Selection
Copy Link
The colDef.cellRendererSelector function allows setting different Cell Components for different Rows within a Column.

The params passed to cellRendererSelector are the same as those passed to the Cell Renderer Component. Typically the selector will use this to check the row's contents and choose a renderer accordingly.

The result is an object with component and params to use instead of cellRenderer and cellRendererParams.

This following shows the selector choosing between Mood and Gender Cell Renderers based on the row data.

cellRendererSelector: params => {

    const type = params.data.type;

    if (type === 'gender') {
        return {
            component: GenderCellRenderer,
            params: {values: ['Male', 'Female']}
        };
    }

    if (type === 'mood') {
        return {
            component: MoodCellRenderer
        };
    }

    return undefined;
}
Another use case for the Selector function is to only render a custom cell component in leaf nodes when Row Grouping. This is done by checking params.node.group and returning undefined for the group nodes.

cellRendererSelector: params => {
    return params.node.group ? undefined : { component: CellRenderer };
},
The example below demonstrates the use of cellRendererSelector to dynamically select a Cell Component based on the row data.

The column 'Value' holds data of different types as shown in the column 'Type' (numbers/genders/moods).
colDef.cellRendererSelector is a function that selects the renderer based on the row data.
The column 'Rendered Value' show the data rendered applying the component and params specified by colDef.cellRendererSelector

 Code
Copy Link
New Tab
CodeSandbox
Plunker
Accessing Instances
Copy Link
After the grid has created an instance of a Cell Component for a cell it is possible to access that instance. This is useful if you want to call a method that you provide on the Cell Component that has nothing to do with the operation of the grid. Accessing Cell Components is done using the grid API getCellRendererInstances(params).

getCellRendererInstances
Copy Link

Function
Returns the list of active cell renderer instances.
RenderApiModule
An example of getting the Cell Component for exactly one cell is as follows:

// example - get cell renderer for first row and column 'gold'
const firstRowNode = api.getDisplayedRowAtIndex(0);
const params = { columns: ['gold'], rowNodes: [firstRowNode] };
const instances = api.getCellRendererInstances(params);

if (instances.length > 0) {
    // got it, user must be scrolled so that it exists
    const instance = instances[0];
}
Note that this method will only return instances of the Cell Component that exists. Due to Row and Column Virtualisation, Cell Components will only exist for Cells that are within the viewport of the Vertical and Horizontal scrolls.

The example below demonstrates custom methods on Cell Components called by the application. The following can be noted:

The medal columns are all using the user defined MedalCellRenderer. The Cell Component has an arbitrary method medalUserFunction() which prints some data to the developer console.
The Gold button executes a method on all instances of the Cell Component in the gold column and prints the data to the developer console.
The First Row Gold button executes a method on the gold cell of the first row only and prints data to the developer console. Note that the getCellRendererInstances() method will return nothing if the grid is scrolled far past the first row showing row virtualisation in action.
The All Cells button executes a method on all instances of all Cell Components and prints data to the developer console.
Console
Clear
Console logs from the example shown here...
 Code
Copy Link
New Tab
CodeSandbox
Plunker
Custom Props
Copy Link
The props passed to the Cell Component can be complemented with custom props. This allows configuring reusable Cell Components - e.g. a component could have buttons that are optionally displayed via additional props.

Complement props to a cell renderer using the Column Definition attribute cellRendererParams. When provided, these props will be merged with the grid provided props.

// define Cell Component to be reused
@Component({
    selector: 'colour-cell',
    template: `<span [style.colour]="params.color">{{params.value}}</span>`
})
class ColourCellComp implements ICellRendererAngularComp {
    params!: ICellRendererParams;

    agInit(params: ICellRendererParams) {
        this.params = params;
    }

    refresh(params: ICellRendererParams) {
        this.params = params;
        // As we have updated the params we return true to let AG Grid know we have handled the refresh.
        // So AG Grid will not recreate the cell renderer from scratch.
        return true;
    }
}

@Component({
    selector: 'my-app',
    template: `
        <ag-grid-angular
                [columnDefs]="columnDefs"
                ...other properties />`
})
export class AppComponent {
    columnDefs = [
        {
            headerName: "Colour 1",
            field: "value",
            cellRenderer: ColourCellComp,
            cellRendererParams: {
                color: 'guinnessBlack'
            }
        },
        {
            headerName: "Colour 2",
            field: "value",
            cellRenderer: ColourCellComp,
            cellRendererParams: {
                color: 'irishGreen'
            }
        }
    ];

    //...
}

This example shows rendering an image with and without custom props and using custom props to pass a callback to a button. The Refresh Data button triggers the cell components to refresh by randomising the success data. The Launch button logs a message to the developer console.

Console
Clear
Console logs from the example shown here...
 Code
Copy Link
New Tab
CodeSandbox
Plunker
Dynamic Tooltips
Copy Link
When working with Custom Cell Renderers it is possible to register custom tooltips that are displayed dynamically by using the setTooltip method.

Properties available on the ICellRendererParams<TData = any, TValue = any, TContext = any> interface.

setTooltip
Copy Link

Function
Sets a tooltip to the main element of this component.
value The value to be displayed by the tooltip
shouldDisplayTooltip A function returning a boolean that allows the tooltip to be displayed conditionally. This option does not work when enableBrowserTooltips={true}.
The example below demonstrates a dynamic tooltip being displayed on Cell Components. The following can be noted:

The Athlete column uses the shouldDisplayTooltip callback to only display Tooltips when the text is not fully displayed.
 Code
Copy Link
New Tab
CodeSandbox
Plunker
Defer Slow Cell Components
Copy Link
If a Custom Cell Component is slow to render, the grid may appear unresponsive due to the custom component blocking the main thread. This can be avoided by deferring the rending of slow components as follows:

{
    cellRenderer: 'SlowCellRenderer',
    cellRendererParams: {
        deferRender: true
    }
}
Deferred components will be rendered after other cells and only after the grid has stopped scrolling. In the meantime, the loading cell renderer will be displayed. If Row Grouping is active only custom cells in leaf nodes will be deferred.

The example below demonstrates the use of deferRender to defer the rendering of an artificially slow cell component. The following can be noted when scrolling:

The column 'Slow Renderer' is deferred and shows the default skeleton cell loader.
The column 'Slow Renderer Custom' is deferred but uses a custom loading cell defined via colDef.loadingCellRenderer.
The column 'Fast Renderer' is a custom component but not deferred so renders immediately along with the other plain cells.
The cellRendererSelector only returns the Slow Cell Renderer for leaf nodes as an optimisation.
 Code
Copy Link
New Tab
CodeSandbox
Plunker
Keyboard Navigation
Copy Link
When using custom Cell Components, the custom Cell Component is responsible for implementing support for keyboard navigation among its focusable elements. This is why by default, focusing a grid cell with a custom Cell Component will focus the entire cell instead of any of the elements inside the custom cell renderer.

In order to handle focus in your custom cell component, implement Custom Cell Component Keyboard Navigation.